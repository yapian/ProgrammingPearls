## 问题描述

     1.输入：一个至多包含1千万个非负整数的文件
     2.特征：①每个数都是小于10000000的非负整数；②没有重复的数字；③数据之间不存在关联关系。
     3.约束：①最多`1MB`的内存空间可用；②磁盘空间充足；③运行时间最多几分钟，最好是线性时间。
     
     4.输出：按升序排列的整数序列。

##位图排序思想

由于待排序的数据记录较多，我们单纯地使用常见的排序方法时间效率较低，运行时间会很长。而且内存空间有限（限制为`1MB`左右），所以我们不能同时把所有整数读入内存（如果每个整数使用7个字节来存储，那么1MB内存空间只能存大约`143000`个数字）。当然我们可以多次读取输入文件，多次排序，但是更好的方案是使用位图排序，可以使用有限的1MB内存空间并只进行一趟排序。

1. 根据待排序集合中最大的数，开辟一个位数组，用来表示待排序集合中的整数；
2. 待排序集合中的数字在位数组中的对应位置置1，其他的置0；

例如，待排序集合`{1,2,3,5,8,13}`可以表示为：`0-1-1-1-0-1-0-0-1-0-0-0-0-1`

这样排序过程自然可以分为三步：
第一步：将所有的位都置为0；
第二步：通过读入文件中的每个整数，将每个对应的位都置为1；
第三步：检验每一位，如果该位为1，输出对应的整数。

注意：位图排序是使用一个二进制位而不是一个整数来表示0或1，这样可以大大地减少所需要的内存空间。使用位图排序的前提是要知道待排序序列中的最大数。位图排序的缺点是有些数没有出现过，仍要为其保留一个位。故位图排序比较适合关键字密集的序列，例如一个城市的电话号码。

##性能：

时间复杂度可达`O(n)`，`1MB`包含`8*1024*1024`个位，所需内存`10000000/(8*1024*1024)=1.20MB`，如果不是严格限制的话可以看做基本符合要求。

## 输出

`bitSet.cpp`的输出如下：

```
0 1 2 5 7 9 10 13 16 20
4
100010010011010100111
```
